# ===================
# WAF NGINX CONFIG (ModSecurity Enabled)
# ===================
# This runs in the owasp/modsecurity-crs:nginx container
# Proxies requests to the app nginx after WAF inspection

# NOTE: resolver is already configured in the base owasp/modsecurity-crs:nginx image
# Use variable for proxy_pass to allow runtime DNS resolution

# Include token to origin map (auto-generated by backend and shared via the
# waf_token_map volume at /etc/nginx/includes/waf_map/token_map.conf)
include /etc/nginx/includes/waf_map/token_map.conf;

# JSON log format for WAF access logs
log_format waf_json escape=json
    '{'
        '"time":"$time_iso8601",'
        '"remote_addr":"$remote_addr",'
        '"method":"$request_method",'
        '"uri":"$uri",'
        '"status":$status,'
        '"body_bytes_sent":$body_bytes_sent,'
        '"request_time":$request_time,'
        '"waf_token":"$waf_token",'
        '"user_agent":"$http_user_agent",'
        '"referer":"$http_referer",'
        '"upstream_addr":"$upstream_addr",'
        '"upstream_status":"$upstream_status"'
    '}';

# HTTP server - redirect to HTTPS in prod
server {
    listen 80;
    server_name _;

    # WAF access log with JSON format
    access_log /var/log/nginx/waf_access.log waf_json;

    # Let's Encrypt ACME challenge
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
        allow all;
    }

    # Health check for WAF
    location /waf-health {
        access_log off;
        return 200 "WAF OK";
        add_header Content-Type text/plain;
    }

    # WAF Reverse Proxy: /waf/{token}/...
    # Routes traffic through ModSecurity then proxies to the mapped origin
    location ~ ^/waf/([a-zA-Z0-9]+)(/.*)?$ {
        set $waf_token $1;
        set $waf_path $2;

        # Look up origin from token map
        if ($waf_origin = "") {
            return 404 '{"error":"Invalid or inactive WAF proxy token"}';
        }

        # Proxy to the origin with WAF inspection
        proxy_pass $waf_origin$waf_path$is_args$args;

        # SSL settings for HTTPS origins (enable SNI)
        proxy_ssl_server_name on;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;

        # Pass original client info
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-WAF-Token $waf_token;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # Buffer settings
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Request body
        client_max_body_size 100M;
    }

    # Redirect all other HTTP to HTTPS (when TLS is enabled)
    location / {
        # In detection/testing mode, proxy to app
        # In production with TLS, uncomment next line and comment proxy_pass:
        # return 301 https://$host$request_uri;
        
        # Use variable for dynamic DNS resolution
        set $backend_upstream "http://nginx:8080";
        proxy_pass $backend_upstream;
        include /etc/nginx/includes/proxy_params.conf;
    }
}

# HTTPS server (enabled when certs are mounted)
server {
    listen 443 ssl;
    http2 on;
    server_name _;

    # WAF access log with JSON format
    access_log /var/log/nginx/waf_access.log waf_json;

    # SSL certificates (mounted from host/Let's Encrypt)
    # Uses the self-signed cert generated at startup for local/dev.
    # Replace with /etc/nginx/ssl/fullchain.pem and /etc/nginx/ssl/privkey.pem when certbot is used.
    ssl_certificate /etc/nginx/conf/server.crt;
    ssl_certificate_key /etc/nginx/conf/server.key;

    # Modern SSL config
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    # ModSecurity is enabled via the base image
    # Rules loaded from /etc/modsecurity.d/

    # WAF health check (bypasses ModSecurity)
    location /waf-health {
        access_log off;
        modsecurity off;
        return 200 "WAF OK";
        add_header Content-Type text/plain;
    }

    # WAF Reverse Proxy: /waf/{token}/...
    # Routes traffic through ModSecurity then proxies to the mapped origin
    location ~ ^/waf/([a-zA-Z0-9]+)(/.*)?$ {
        set $waf_token $1;
        set $waf_path $2;

        # Look up origin from token map
        if ($waf_origin = "") {
            return 404 '{"error":"Invalid or inactive WAF proxy token"}';
        }

        # Proxy to the origin with WAF inspection
        proxy_pass $waf_origin$waf_path$is_args$args;

        # SSL settings for HTTPS origins (enable SNI)
        proxy_ssl_server_name on;
        proxy_ssl_protocols TLSv1.2 TLSv1.3;

        # Pass original client info
        proxy_set_header Host $proxy_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-WAF-Token $waf_token;

        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # Buffer settings
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
        proxy_busy_buffers_size 256k;

        # Request body
        client_max_body_size 100M;
    }

    # All other requests go through ModSecurity to app
    location / {
        # Use variable for dynamic DNS resolution
        set $backend_upstream "http://nginx:8080";
        proxy_pass $backend_upstream;
        include /etc/nginx/includes/proxy_params.conf;
    }
}



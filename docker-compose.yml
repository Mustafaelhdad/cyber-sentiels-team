# ===================
# PRODUCTION DOCKER COMPOSE (HOST NETWORK MODE)
# ===================
# For VPS deployment with broken Docker iptables.
# All public-facing services use host network mode to bypass DNAT issues.
# Internal services communicate via localhost ports.

services:
  # ===================
  # Flask WAF Proxy (Host Network)
  # ===================
  waf:
    build:
      context: ./tools/waf
      dockerfile: Dockerfile
    container_name: sentinel_waf_flask
    network_mode: host
    environment:
      - WAF_MAP_FILE=/tmp/waf-map.json
      - WAF_HOST=127.0.0.1
      - WAF_PORT=5050
      - WAF_DEBUG=${WAF_DEBUG:-false}
      - WAF_PROXY_TIMEOUT=${WAF_PROXY_TIMEOUT:-30}
    volumes:
      - waf_shared:/tmp
      - waf_logs:/app/logs
    healthcheck:
      test:
        [
          "CMD",
          "python",
          "-c",
          "import urllib.request; urllib.request.urlopen('http://127.0.0.1:5050/health')",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # NGINX (Public Gateway - Host Network)
  # ===================
  nginx:
    build:
      context: ./infra/docker/nginx
      dockerfile: Dockerfile
    container_name: sentinel_nginx
    network_mode: host
    volumes:
      - certbot_www:/var/www/certbot:ro
      - certbot_certs:/etc/nginx/ssl:ro
    depends_on:
      - backend
      - waf
    restart: unless-stopped

  # ===================
  # BACKEND (Laravel PHP-FPM - Host Network)
  # ===================
  backend:
    build:
      context: .
      dockerfile: infra/docker/php/Dockerfile
    container_name: sentinel_backend
    network_mode: host
    working_dir: /var/www/backend
    environment:
      - APP_NAME=Sentinel
      - APP_ENV=${APP_ENV:-production}
      - APP_KEY=${APP_KEY:-base64:vSvZE7y8wV6beMhp/aMaJgCvdEncsgPvb8ogyDMp7p4=}
      - APP_DEBUG=${APP_DEBUG:-false}
      - APP_URL=${APP_URL:-http://localhost}
      - LOG_CHANNEL=stack
      - LOG_LEVEL=info
      - DB_CONNECTION=mysql
      - DB_HOST=127.0.0.1
      - DB_PORT=3306
      - DB_DATABASE=${DB_DATABASE:-sentinel}
      - DB_USERNAME=${DB_USERNAME:-sentinel}
      - DB_PASSWORD=${DB_PASSWORD:-secret}
      - REDIS_HOST=127.0.0.1
      - REDIS_PORT=6379
      - CACHE_DRIVER=redis
      - QUEUE_CONNECTION=redis
      - SESSION_DRIVER=redis
      - WAF_BASE_URL=${WAF_BASE_URL:-http://72.62.93.170}
      - WAF_MAP_FILE_PATH=/tmp/waf-map.json
      - WAF_LOG_FILE=/var/log/waf/suspicious.log
      - ZAP_API_URL=http://127.0.0.1:8081
      - SAST_API_URL=http://127.0.0.1:8082
      - RASP_API_URL=http://127.0.0.1:9001
      - SIEM_API_URL=http://127.0.0.1:5051
      - AUTH_API_URL=http://127.0.0.1:5052
      - AUTHZ_API_URL=http://127.0.0.1:5053
      - PROVISION_API_URL=http://127.0.0.1:5054
      # In-app RASP configuration
      - RASP_ENABLED=${RASP_ENABLED:-false}
      - RASP_MODE=${RASP_MODE:-monitor}
      - RASP_SINK_DATABASE=${RASP_SINK_DATABASE:-true}
      - RASP_SINK_HTTP=${RASP_SINK_HTTP:-true}
      - RASP_SINK_FILESYSTEM=${RASP_SINK_FILESYSTEM:-true}
      - RASP_QUEUE_CONNECTION=redis
      - RASP_QUEUE_NAME=rasp
      - RASP_LOG_CHANNEL=rasp
      - RASP_LOG_LEVEL=${RASP_LOG_LEVEL:-info}
    volumes:
      - laravel_storage:/var/www/backend/storage
      - reports_artifacts:/var/www/backend/storage/app/reports
      - waf_shared:/tmp
      - waf_logs:/var/log/waf:ro
    depends_on:
      - mysql
      - redis
    restart: unless-stopped

  # ===================
  # QUEUE WORKER (Laravel Horizon - Host Network)
  # ===================
  queue:
    build:
      context: .
      dockerfile: infra/docker/php/Dockerfile
    container_name: sentinel_queue
    network_mode: host
    working_dir: /var/www/backend
    command: php artisan horizon
    environment:
      - APP_NAME=Sentinel
      - APP_ENV=${APP_ENV:-production}
      - APP_KEY=${APP_KEY:-base64:vSvZE7y8wV6beMhp/aMaJgCvdEncsgPvb8ogyDMp7p4=}
      - APP_DEBUG=${APP_DEBUG:-false}
      - DB_CONNECTION=mysql
      - DB_HOST=127.0.0.1
      - DB_PORT=3306
      - DB_DATABASE=${DB_DATABASE:-sentinel}
      - DB_USERNAME=${DB_USERNAME:-sentinel}
      - DB_PASSWORD=${DB_PASSWORD:-secret}
      - REDIS_HOST=127.0.0.1
      - REDIS_PORT=6379
      - CACHE_DRIVER=redis
      - QUEUE_CONNECTION=redis
      - WAF_MAP_FILE_PATH=/tmp/waf-map.json
      - WAF_LOG_FILE=/var/log/waf/suspicious.log
      - SAST_API_URL=http://127.0.0.1:8082
      - RASP_API_URL=http://127.0.0.1:9001
      - SIEM_API_URL=http://127.0.0.1:5051
      - ZAP_API_URL=http://127.0.0.1:8081
      - AUTH_API_URL=http://127.0.0.1:5052
      - AUTHZ_API_URL=http://127.0.0.1:5053
      - PROVISION_API_URL=http://127.0.0.1:5054
      # In-app RASP configuration
      - RASP_ENABLED=${RASP_ENABLED:-false}
      - RASP_MODE=${RASP_MODE:-monitor}
      - RASP_SINK_DATABASE=${RASP_SINK_DATABASE:-true}
      - RASP_SINK_HTTP=${RASP_SINK_HTTP:-true}
      - RASP_SINK_FILESYSTEM=${RASP_SINK_FILESYSTEM:-true}
      - RASP_QUEUE_CONNECTION=redis
      - RASP_QUEUE_NAME=rasp
      - RASP_LOG_CHANNEL=rasp
      - RASP_LOG_LEVEL=${RASP_LOG_LEVEL:-info}
    volumes:
      - laravel_storage:/var/www/backend/storage
      - reports_artifacts:/var/www/backend/storage/app/reports
      - waf_shared:/tmp
      - waf_logs:/var/log/waf:ro
    depends_on:
      - mysql
      - redis
      - backend
    restart: unless-stopped

  # ===================
  # SCHEDULER (Laravel Cron - Host Network)
  # ===================
  scheduler:
    build:
      context: .
      dockerfile: infra/docker/php/Dockerfile
    container_name: sentinel_scheduler
    network_mode: host
    working_dir: /var/www/backend
    command: sh -c "while true; do php artisan schedule:run --verbose --no-interaction & sleep 60; done"
    environment:
      - APP_NAME=Sentinel
      - APP_ENV=${APP_ENV:-production}
      - APP_KEY=${APP_KEY:-base64:vSvZE7y8wV6beMhp/aMaJgCvdEncsgPvb8ogyDMp7p4=}
      - APP_DEBUG=${APP_DEBUG:-false}
      - DB_CONNECTION=mysql
      - DB_HOST=127.0.0.1
      - DB_PORT=3306
      - DB_DATABASE=${DB_DATABASE:-sentinel}
      - DB_USERNAME=${DB_USERNAME:-sentinel}
      - DB_PASSWORD=${DB_PASSWORD:-secret}
      - REDIS_HOST=127.0.0.1
      - REDIS_PORT=6379
      - CACHE_DRIVER=redis
      - QUEUE_CONNECTION=redis
      - WAF_MAP_FILE_PATH=/tmp/waf-map.json
      - WAF_LOG_FILE=/var/log/waf/suspicious.log
    volumes:
      - laravel_storage:/var/www/backend/storage
      - reports_artifacts:/var/www/backend/storage/app/reports
      - waf_shared:/tmp
      - waf_logs:/var/log/waf:ro
    depends_on:
      - mysql
      - redis
      - backend
    restart: unless-stopped

  # ===================
  # MYSQL (Host Network)
  # ===================
  mysql:
    image: mysql:8.0
    container_name: sentinel_mysql
    network_mode: host
    environment:
      - MYSQL_DATABASE=${DB_DATABASE:-sentinel}
      - MYSQL_USER=${DB_USERNAME:-sentinel}
      - MYSQL_PASSWORD=${DB_PASSWORD:-secret}
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD:-rootsecret}
    volumes:
      - mysql_data:/var/lib/mysql
    restart: unless-stopped

  # ===================
  # REDIS (Host Network)
  # ===================
  redis:
    image: redis:7-alpine
    container_name: sentinel_redis
    network_mode: host
    command: redis-server --appendonly yes --bind 127.0.0.1
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # ===================
  # SAST Scanner (Host Network - Port 8082)
  # ===================
  sast:
    build:
      context: ./tools/dast_and_sast
      dockerfile: Dockerfile
    container_name: sentinel_sast
    network_mode: host
    environment:
      - SAST_RULES_FILE=/app/config/sast_rules.yaml
      - SAST_OUTPUT_DIR=/app/output
      - SAST_SCANS_DIR=/app/scans
      - MAX_UPLOAD_SIZE=${SAST_MAX_UPLOAD_SIZE:-104857600}
      - SAST_HOST=127.0.0.1
      - SAST_PORT=8082
    volumes:
      - sast_output:/app/output
      - sast_scans:/app/scans
      - reports_artifacts:/app/reports:rw
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:8082/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # RASP (Runtime App Self-Protection - Host Network - Port 9001)
  # ===================
  rasp:
    build:
      context: ./tools/RASP
      dockerfile: Dockerfile
    container_name: sentinel_rasp
    network_mode: host
    environment:
      - RASP_PORT=9001
      - RASP_HOST=127.0.0.1
      - RASP_DB_PATH=/data/rasp_incidents.db
      - RASP_ENABLE_DEMO=${RASP_ENABLE_DEMO:-false}
    volumes:
      - rasp_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:9001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # SIEM (Security Information & Event Management - Host Network - Port 5051)
  # ===================
  siem:
    build:
      context: ./tools/siem
      dockerfile: Dockerfile
    container_name: sentinel_siem
    network_mode: host
    environment:
      - SIEM_HOST=127.0.0.1
      - SIEM_PORT=5051
      - SIEM_WORKERS=${SIEM_WORKERS:-2}
      - SIEM_TIMEOUT=${SIEM_TIMEOUT:-120}
      - SIEM_SECRET_KEY=${SIEM_SECRET_KEY:-change-this-in-production}
      - SIEM_TIP_ENABLED=${SIEM_TIP_ENABLED:-false}
      - SIEM_TIP_MODEL_DIR=/app/model
      - SIEM_REALTIME_POLL_INTERVAL=${SIEM_REALTIME_POLL_INTERVAL:-0.5}
    volumes:
      - siem_data:/data
      - siem_logs:/app/logs
      - siem_uploads:/app/uploads
      - siem_reports:/app/reports
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:5051/stats"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # Authentication Service (Host Network - Port 5052)
  # ===================
  auth:
    build:
      context: ./tools/Authentication
      dockerfile: Dockerfile
    container_name: sentinel_auth
    network_mode: host
    environment:
      - AUTH_HOST=127.0.0.1
      - AUTH_PORT=5052
      # Using 1 worker because sessions are stored in-memory
      # Multiple workers would cause session lookup failures
      - AUTH_WORKERS=${AUTH_WORKERS:-1}
      - AUTH_TIMEOUT=${AUTH_TIMEOUT:-60}
      - AUTH_JWT_SECRET=${AUTH_JWT_SECRET:-change-this-in-production}
      - AUTH_JWT_TTL=${AUTH_JWT_TTL:-3600}
      - AUTH_STATIC_OTP=${AUTH_STATIC_OTP:-5555}
      - AUTH_USER_FILE=/data/users.txt
      - AUTH_DEBUG=${AUTH_DEBUG:-false}
    volumes:
      - auth_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:5052/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # Authorization Service (RBAC/ABAC - Host Network - Port 5053)
  # ===================
  authz:
    build:
      context: ./tools/Authorization
      dockerfile: Dockerfile
    container_name: sentinel_authz
    network_mode: host
    environment:
      - AUTHZ_HOST=127.0.0.1
      - AUTHZ_PORT=5053
      - AUTHZ_WORKERS=${AUTHZ_WORKERS:-2}
      - AUTHZ_TIMEOUT=${AUTHZ_TIMEOUT:-60}
      - AUTHZ_USER_FILE=/data/users.txt
      - AUTHZ_LOG_FILE=/data/authorization.log
      - AUTHZ_DEFAULT_GROUP=${AUTHZ_DEFAULT_GROUP:-general}
      - AUTHZ_ADMIN_PIN=${AUTHZ_ADMIN_PIN:-1234}
      - AUTHZ_DEBUG=${AUTHZ_DEBUG:-false}
    volumes:
      - authz_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:5053/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # Account Provisioning Service (IAM - Host Network - Port 5054)
  # ===================
  provision:
    build:
      context: ./tools/account_provisioning_tool
      dockerfile: Dockerfile
    container_name: sentinel_provision
    network_mode: host
    environment:
      - PROVISION_HOST=127.0.0.1
      - PROVISION_PORT=5054
      - PROVISION_WORKERS=${PROVISION_WORKERS:-2}
      - PROVISION_TIMEOUT=${PROVISION_TIMEOUT:-60}
      - PROVISION_DB_PATH=/data/users.db
      - PROVISION_REPORTS_DIR=/data/reports
      - PROVISION_DEBUG=${PROVISION_DEBUG:-false}
    volumes:
      - provision_data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:5054/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # ===================
  # OWASP ZAP (DAST Tool - Host Network - Port 8081)
  # ===================
  zap:
    image: ghcr.io/zaproxy/zaproxy:stable
    container_name: sentinel_zap
    network_mode: host
    command: zap.sh -daemon -host 127.0.0.1 -port 8081 -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true -config api.disablekey=true
    mem_limit: 3g
    cpus: "1.5"
    pids_limit: 512
    environment:
      - JAVA_OPTS=-Xmx2048m
    volumes:
      - zap_data:/zap/wrk
    healthcheck:
      test:
        ["CMD", "curl", "-f", "http://127.0.0.1:8081/JSON/core/view/version/"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    restart: unless-stopped

  # ===================
  # CERTBOT (SSL Certificate Management - Host Network)
  # ===================
  # This container handles SSL certificate issuance and renewal.
  # - Only issues new certs if they don't exist
  # - Only renews if certs are within 30 days of expiry (certbot's default)
  # - Checks every 12 hours but won't renew unless needed
  certbot:
    image: certbot/certbot:latest
    container_name: sentinel_certbot
    network_mode: host
    volumes:
      - certbot_www:/var/www/certbot:rw
      - certbot_certs:/etc/letsencrypt:rw
    entrypoint: >
      /bin/sh -c '
        trap exit TERM;
        
        # Function to check certificate validity
        check_cert_validity() {
          if [ -f /etc/letsencrypt/live/cybersentinels.cloud/fullchain.pem ]; then
            # Check if cert expires in more than 30 days
            EXPIRY=$$(openssl x509 -enddate -noout -in /etc/letsencrypt/live/cybersentinels.cloud/fullchain.pem 2>/dev/null | cut -d= -f2)
            if [ -n "$$EXPIRY" ]; then
              EXPIRY_EPOCH=$$(date -d "$$EXPIRY" +%s 2>/dev/null || date -j -f "%b %d %H:%M:%S %Y %Z" "$$EXPIRY" +%s 2>/dev/null)
              NOW_EPOCH=$$(date +%s)
              DAYS_LEFT=$$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
              echo "Certificate expires in $$DAYS_LEFT days ($$EXPIRY)"
              return $$DAYS_LEFT
            fi
          fi
          return 0
        }
        
        # Initial certificate check/issuance
        echo "=== Certbot SSL Manager Starting ==="
        
        if [ ! -f /etc/letsencrypt/live/cybersentinels.cloud/fullchain.pem ]; then
          echo "No certificate found. Attempting to issue new certificate..."
          sleep 10;  # Wait for nginx to be ready
          certbot certonly --webroot -w /var/www/certbot \
            -d cybersentinels.cloud -d www.cybersentinels.cloud \
            --email admin@cybersentinels.cloud \
            --agree-tos --no-eff-email --non-interactive \
            --keep-until-expiring --expand
          
          if [ $$? -eq 0 ]; then
            echo "Certificate issued successfully!"
          else
            echo "Certificate issuance failed. Will retry on next cycle."
          fi
        else
          echo "Certificate already exists."
          check_cert_validity
        fi
        
        # Renewal loop - check every 12 hours
        while :; do
          echo "=== Certificate renewal check at $$(date) ==="
          
          if [ -f /etc/letsencrypt/live/cybersentinels.cloud/fullchain.pem ]; then
            check_cert_validity
            DAYS=$$?
            
            if [ $$DAYS -lt 30 ]; then
              echo "Certificate expires in less than 30 days. Attempting renewal..."
              certbot renew --webroot -w /var/www/certbot --non-interactive --deploy-hook "echo Cert renewed successfully"
              
              if [ $$? -eq 0 ]; then
                echo "Renewal check completed."
              fi
            else
              echo "Certificate still valid for $$DAYS days. No renewal needed."
            fi
          else
            echo "No certificate found. Attempting to issue..."
            certbot certonly --webroot -w /var/www/certbot \
              -d cybersentinels.cloud -d www.cybersentinels.cloud \
              --email admin@cybersentinels.cloud \
              --agree-tos --no-eff-email --non-interactive \
              --keep-until-expiring --expand
          fi
          
          echo "Next check in 12 hours..."
          sleep 12h & wait $${!};
        done
      '
    depends_on:
      - nginx
    restart: unless-stopped

# No networks needed - all services use host network

volumes:
  mysql_data:
    driver: local
  redis_data:
    driver: local
  laravel_storage:
    driver: local
  reports_artifacts:
    driver: local
  waf_shared:
    driver: local
  waf_logs:
    driver: local
  certbot_www:
    driver: local
  certbot_certs:
    driver: local
  zap_data:
    driver: local
  sast_output:
    driver: local
  sast_scans:
    driver: local
  rasp_data:
    driver: local
  siem_data:
    driver: local
  siem_logs:
    driver: local
  siem_uploads:
    driver: local
  siem_reports:
    driver: local
  auth_data:
    driver: local
  authz_data:
    driver: local
  provision_data:
    driver: local
